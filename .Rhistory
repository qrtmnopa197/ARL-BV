source("~/projects/spring_2022_study/code/functions/s22_utilities.R", echo=TRUE)
##SET MANUALLY
path_to_project_directory <- "~/projects/ARL/"
path_to_s22 <- "~/projects/spring_2022_study/"
ids_to_exclude <- c(1:18) #Ps whose data you don't want to analyze even if it looks good. Exclude 86041 - the test code - and 1 - obviously a pilot ID code.
#clear out results from old analyses
system("mv /Users/dp/projects/ARL/analysis_data/*.csv /Users/dp/projects/ARL/analysis_data/old_analysis_data") #move any CSV files in this folder to old_analysis_data folder
system("rm -rf /Users/dp/projects/ARL/analysis_data/qc_plots/trial_level_vars/*") #clear the folder containing trial-level plots
system("rm -f /Users/dp/projects/ARL/analysis_data/qc_plots/sub_level_variables.pdf") #remove old subject level variable plot
source(paste0(path_to_s22,"code/functions/s22_utilities.R")) #get s22 functions
source(paste0(path_to_project_directory,"code/functions/arl_wrangle_psychopy_data.R"))
csvs_to_analyze <- get_csvs_to_analyze(path_to_project_directory,ids_to_exclude) #get the usable CSVs to analyze
csvs_to_analyze
csv_path <- "/Users/dp/projects/ARL/input_data/28_arl_task_03-07-2023_15h06.41.878.csv"
library(ddpcr)
library(tidyverse)
library(sigmoid)
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys")))
view(sub-info)
view(sub_info)
csvs_path <- "/Users/dp/projects/ARL/input_data/32_arl_task_03-07-2023_15h40.09.578.csv"
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
library(ddpcr)
library(tidyverse)
library(sigmoid)
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fractalA",fB_img = "fractalB",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
view(sub_info)
view(trials)
csv_path
csv_path <- "/Users/dp/projects/ARL/input_data/32_arl_task_03-07-2023_15h40.09.578.csv"
library(ddpcr)
library(tidyverse)
library(sigmoid)
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fractalA",fB_img = "fractalB",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
view(sub_info)
view(trials)
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
aff_qs_run
trials$aff_qs.ran
view(trials)
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fractalA",fB_img = "fractalB",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
view(trials)
aff_qs_run
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
main_task_start
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
view(trials)
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
view(trials)
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
library(ddpcr)
library(tidyverse)
library(sigmoid)
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fractalA",fB_img = "fractalB",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
old_trials <- trials
trials$delete_row <- 0
for(row in 1:nrow(trials)){
#On rows where a pre-trial ratchet-down has occurred...
if (!is.na(trials$trials_and_makeups.ran[row]) | !(is.na(trials$blocks.ran[row]))){
trials$delete_row[row] <- 1 #mark row for deletion
} else if (!(is.na(trials$remaining_trial.ran[row]))){
#Mid-trial ratchet-down. First, copy all the valuable data from the row below to the row on which the trial started.
row_below <- row + 1
trials$trial_raw[row] <- trials$trial_raw[row_below]
trials$fB_img[row] <- trials$fB_img[row_below]
trials$fA_img[row] <- trials$fA_img[row_below]
trials$fA_rew_dist[row]<- trials$fA_rew_dist[row_below]
trials$fA_fo_dist[row]<- trials$fA_fo_dist[row_below]
trials$fB_rew_dist[row]<- trials$fB_rew_dist[row_below]
trials$fB_fo_dist[row]<- trials$fB_fo_dist[row_below]
trials$pair[row] <- trials$pair[row_below]
if(any(names(trials) == "too_slow")){
trials$too_slow[row] <- trials$too_slow[row_below]
}
#Now, mark the row below (containing only redundant data) for deletion
trials$delete_row[row_below] <- 1
}
}
trials <- filter(trials, delete_row == 0) #actually delete the marked rows
trials <- select(trials, -delete_row,-ends_with(".ran")) #get rid of .ran and delete_row columns
library(ddpcr)
library(tidyverse)
library(sigmoid)
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fractalA",fB_img = "fractalB",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
old_trials <- trials
view(trials)
trials$delete_row <- 0
for(row in 1:nrow(trials)){
#On rows where a pre-trial ratchet-down has occurred...
if (!is.na(trials$trials_and_makeups.ran[row]) | !(is.na(trials$blocks.ran[row]))){
trials$delete_row[row] <- 1 #mark row for deletion
} else if (!(is.na(trials$remaining_trial.ran[row]))){
#Mid-trial ratchet-down. First, copy all the valuable data from the row below to the row on which the trial started.
row_below <- row + 1
trials$trial_raw[row] <- trials$trial_raw[row_below]
trials$fB_img[row] <- trials$fB_img[row_below]
trials$fA_img[row] <- trials$fA_img[row_below]
trials$fA_rew_dist[row]<- trials$fA_rew_dist[row_below]
trials$fA_fo_dist[row]<- trials$fA_fo_dist[row_below]
trials$fB_rew_dist[row]<- trials$fB_rew_dist[row_below]
trials$fB_fo_dist[row]<- trials$fB_fo_dist[row_below]
trials$pair[row] <- trials$pair[row_below]
if(any(names(trials) == "too_slow")){
trials$too_slow[row] <- trials$too_slow[row_below]
}
#Now, mark the row below (containing only redundant data) for deletion
trials$delete_row[row_below] <- 1
}
}
trials <- filter(trials, delete_row == 0) #actually delete the marked rows
trials <- select(trials, -delete_row,-ends_with(".ran")) #get rid of .ran and delete_row columns
warnings()
if(!is.function(get_csvs_to_analyze)){
stop("get_csvs_to_analyze() is not loaded into the environment of arl_wrangle_psychopy_data(), suggesting that the functions in s22_utilities.R are not present in the function's environment.")
}
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist",fA_img = "fA_img",fB_img = "fB_img",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
"val_rat_onset_time", val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
trials <- old_trials
view(trials)
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist","fA_img","fB_img",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
# You want one row per trial, meaning you want to ratchet down one row at the end of every trial.
# Fortunately, the end of each trial is marked by a loop end, so psychopy does indeed ratchet down one row
# at the end of every trial. However, there are a few loops that sometimes end in between trials -
#  i.e., before the trial starts, with the first trial always starting on the right row -
# leading to an unnecessary ratchet-down before the start of the next trial, before any trial data has been collected.
# To resolve this issue, you can simply delete all rows on which these loops have run/the pre-trial ratchet-down
# has occurred (since no trial data is collected before the ratchet-down).
# A second issue is that there’s a loop which sometimes ends in the middle of a trial (remaining_trial),
# which results in a single trial’s data being spread across two lines.
# To address this, you should identify trials in which there was a ratchet-down mid-trial.
# In these cases, you know that the current row and the row below it represent a single trial’s data,
# and that you need to combine them into one row. The simplest way to do this is to copy the trial data
# on the second row to the first row, thus ensuring that the first row contai
view(trials)
source("~/projects/ARL/code/functions/arl_wrangle_psychopy_data.R")
old_trials <- trials
trials$delete_row <- 0
for(row in 1:nrow(trials)){
#On rows where a pre-trial ratchet-down has occurred...
if (!is.na(trials$trials_and_makeups.ran[row]) | !(is.na(trials$blocks.ran[row]))){
trials$delete_row[row] <- 1 #mark row for deletion
} else if (!(is.na(trials$remaining_trial.ran[row]))){
#Mid-trial ratchet-down. First, copy all the valuable data from the row below to the row on which the trial started.
row_below <- row + 1
trials$trial_raw[row] <- trials$trial_raw[row_below]
trials$fB_img[row] <- trials$fB_img[row_below]
trials$fA_img[row] <- trials$fA_img[row_below]
trials$fA_rew_dist[row]<- trials$fA_rew_dist[row_below]
trials$fA_fo_dist[row]<- trials$fA_fo_dist[row_below]
trials$fB_rew_dist[row]<- trials$fB_rew_dist[row_below]
trials$fB_fo_dist[row]<- trials$fB_fo_dist[row_below]
if(any(names(trials) == "too_slow")){
trials$too_slow[row] <- trials$too_slow[row_below]
}
#Now, mark the row below (containing only redundant data) for deletion
trials$delete_row[row_below] <- 1
}
}
trials <- filter(trials, delete_row == 0) #actually delete the marked rows
trials <- select(trials, -delete_row,-ends_with(".ran")) #get rid of .ran and delete_row columns
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist","fA_img","fB_img",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
trials$trials_and_makeups.ran
# leading to an unnecessary ratchet-down before the start of the next trial, before any trial data has been collected.
# To resolve this issue, you can simply delete all rows on which these loops have run/the pre-trial ratchet-down
# has occurred (since no trial data is collected before the ratchet-down).
# A second issue is that there’s a loop which sometimes ends in the middle of a trial (remaining_trial),
# which results in a single trial’s data being spread across two lines.
# To address this, you should identify trials in which there was a ratchet-down mid-trial.
# In these cases, you know that the current row and the row below it represent a single trial’s data,
# and that you need to combine them into one row. The simplest way to do this is to copy the trial data
# on the second row to the first row, thus ensuring that the first row contains the full trial’s data.
# Then, delete the second row, which contains only redundant information.
trials$delete_row <- 0
trials$blocks.ran
for(row in 1:nrow(trials)){
#On rows where a pre-trial ratchet-down has occurred...
if (!is.na(trials$trials_and_makeups.ran[row]) | !(is.na(trials$blocks.ran[row]))){
trials$delete_row[row] <- 1 #mark row for deletion
} else if (!(is.na(trials$remaining_trial.ran[row]))){
#Mid-trial ratchet-down. First, copy all the valuable data from the row below to the row on which the trial started.
row_below <- row + 1
trials$trial_raw[row] <- trials$trial_raw[row_below]
trials$fB_img[row] <- trials$fB_img[row_below]
trials$fA_img[row] <- trials$fA_img[row_below]
trials$fA_rew_dist[row]<- trials$fA_rew_dist[row_below]
trials$fA_fo_dist[row]<- trials$fA_fo_dist[row_below]
trials$fB_rew_dist[row]<- trials$fB_rew_dist[row_below]
trials$fB_fo_dist[row]<- trials$fB_fo_dist[row_below]
if(any(names(trials) == "too_slow")){
trials$too_slow[row] <- trials$too_slow[row_below]
}
#Now, mark the row below (containing only redundant data) for deletion
trials$delete_row[row_below] <- 1
}
}
trials <- filter(trials, delete_row == 0) #actually delete the marked rows
trials <- select(trials, -delete_row,-ends_with(".ran")) #get rid of .ran and delete_row columns
view(old_trials)
print(csv_path) #print the csv path for debugging purposes - so you know what subject you're on
df_full <- read_csv(csv_path) #read in subject's data
#if the subject never pressed the right arrow key on affect probes, the RT columns won't appear. Thus, you need to create fully empty RT columns for them.
if(!("val_rat.rt" %in% names(df_full))){
df_full$val_rat.rt <- NA
}
#make one df with all the subject-level info, and a second with all the trial-level info
sub_info <- select(df_full, any_of(c(id = "id", "age_gender_formresponse", "date", "earnings_before_ec", total_experiment_time = "total_experiment_time",
comp_qs = "mouse_3.clicked_name",instruct_keypress = "instruct_key.keys",
is_check = "pressq_interscreen.keys", rev_check = "pressq_reveal.keys", val_check = "pressq_valrat.keys")))
trials <- select(df_full, any_of(c("fA_rew_dist","fA_fo_dist","fB_rew_dist","fB_fo_dist","fA_img","fB_img",
dec_rt = "mouse.rt", too_slow = "too_slow",choice = "mouse.clicked_name","reward","fake_out",
val_rat = "val_slider.response", val_rat_rt = "val_rat.rt",
trial_raw = "trials.thisN", block_raw = "blocks.thisN", makeup_repetition = "trials_and_makeups.thisN")),
ends_with(".ran"))
#FIRST, REFORMAT THE TRIALS DF...
#Find the rows containing the first and last trials, getting rid of everything above and below those...
aff_qs_run <- which(trials$aff_qs.ran == 1) #identify the rows on which aff_qs - the last loop before the main task - ran
main_task_start <- max(aff_qs_run) + 1 #the row after the last run of this loop should be the first trial
block_runs <- which(trials$blocks.ran == 1) #identify all rows on which the blocks loop ran.
main_task_end <- max(block_runs) #the last run of this loop signifies the end of the main task
trials <- trials[main_task_start:main_task_end,] #keep only rows within the main task
#Create columns for block number and what makeup/repetition a trial represents
#Block number and makeup/repetition number are output at the end of each block/repetition loop,
#so you need to fill out all the rows above each loop end
#with that value. You can use the custom "fill_vec" function to do this (see s22_functions.R in this folder)
trials$block_raw <- fill_vec(trials$block_raw, bottom_up = TRUE)
trials$makeup_repetition <- fill_vec(trials$makeup_repetition, bottom_up = TRUE)
old_trials <- trials
trials$delete_row <- 0
for(row in 1:nrow(trials)){
#On rows where a pre-trial ratchet-down has occurred...
if (!is.na(trials$trials_and_makeups.ran[row]) | !(is.na(trials$blocks.ran[row]))){
trials$delete_row[row] <- 1 #mark row for deletion
} else if (!(is.na(trials$remaining_trial.ran[row]))){
#Mid-trial ratchet-down. First, copy all the valuable data from the row below to the row on which the trial started.
row_below <- row + 1
trials$trial_raw[row] <- trials$trial_raw[row_below]
trials$fB_img[row] <- trials$fB_img[row_below]
trials$fA_img[row] <- trials$fA_img[row_below]
trials$fA_rew_dist[row]<- trials$fA_rew_dist[row_below]
trials$fA_fo_dist[row]<- trials$fA_fo_dist[row_below]
trials$fB_rew_dist[row]<- trials$fB_rew_dist[row_below]
trials$fB_fo_dist[row]<- trials$fB_fo_dist[row_below]
if(any(names(trials) == "too_slow")){
trials$too_slow[row] <- trials$too_slow[row_below]
}
#Now, mark the row below (containing only redundant data) for deletion
trials$delete_row[row_below] <- 1
}
}
trials <- filter(trials, delete_row == 0) #actually delete the marked rows
trials <- select(trials, -delete_row,-ends_with(".ran")) #get rid of .ran and delete_row columns
view(old_trials)
view(trials)
##SET MANUALLY
path_to_project_directory <- "~/projects/ARL/"
path_to_s22 <- "~/projects/spring_2022_study/"
ids_to_exclude <- c(1:18,9999) #Ps whose data you don't want to analyze even if it looks good. Exclude 86041 - the test code - and 1 - obviously a pilot ID code.
##############
#clear out results from old analyses
system("mv /Users/dp/projects/ARL/analysis_data/*.csv /Users/dp/projects/ARL/analysis_data/old_analysis_data") #move any CSV files in this folder to old_analysis_data folder
system("rm -rf /Users/dp/projects/ARL/analysis_data/qc_plots/trial_level_vars/*") #clear the folder containing trial-level plots
system("rm -f /Users/dp/projects/ARL/analysis_data/qc_plots/sub_level_variables.pdf") #remove old subject level variable plot
source(paste0(path_to_s22,"code/functions/s22_utilities.R")) #get s22 functions
source(paste0(path_to_project_directory,"code/functions/arl_utilities.R"))
source(paste0(path_to_project_directory,"code/functions/arl_wrangle_psychopy_data.R"))
csvs_to_analyze <- get_csvs_to_analyze(path_to_project_directory,ids_to_exclude) #get the usable CSVs to analyze
all_data <- lapply(csvs_to_analyze, arl_wrangle_psychopy_data) #reformats each CSV, turning it into a long dataset usable for analysis, and adds all variables of interest that can be created from the raw data alone.
#Returns a list - one element for each subject - where each element is itself a list containing dfs with the trial-level data and subject-level data
trials_list <- lapply(all_data, function(l) l[[1]]) #get a list of the trial-level dfs only
trial_level_data <- do.call(rbind,trials_list) #stack trial dfs into one big df
sub_list <- lapply(all_data, function(l) l[[2]]) #get a list of the subject-level dfs only
sub_level_data <- do.call(rbind,sub_list) #stack them into one big data frame
#write both to CSVs
date_time <- Sys.time() %>% chartr(" ","_",.) %>% chartr(":","_",.) #grab the date and time, reformatting ':' and '-' to  '_' so you can label the files with it
write.csv(trial_level_data,paste0(path_to_project_directory,"analysis_data/trial_level_data_all_subs_",date_time,".csv"),row.names = FALSE)
#write subject-level data
write.csv(sub_level_data,paste0(path_to_project_directory,"analysis_data/sub_level_data_all_subs_",date_time,".csv"),row.names = FALSE)
#Create plot grids of select variables for quality checking. These are saved to the qc_plots folder
tl_hists <- c("val_rat_rt","dec_rt","val_rat") #trial level variables to plot
plot_trial_level_vars(trial_level_data,tl_hists,path_to_project_directory) #create and save plot grids
sl_hists <- c("consecutive_late_choices","instruct_keypress","valrat_autoprocess",
"answers_correct","answers_incorrect","earnings_before_ec",
"is_check_passed","rev_check_passed","val_check_passed","att_checks_passed",
"percent_left","late_percent","trials_completed","valrat_skipped_percent","sd_valrat",
"mean_dec_rt","mean_valrat_rt","total_experiment_time") #subject-level variables to plot
plot_sub_level_vars(sub_level_data,sl_hists,path_to_project_directory) #create and save plot grids
