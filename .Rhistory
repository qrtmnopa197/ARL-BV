#add a column with completed trial numbers - the trial indices if you ignore late trials. These will match the "t" trial numbers used in the Stan models
trials <- do.call(rbind,by(trials,trials$sub_index,add_trials_nl))
trials$overall_trial_nl <- 1:nrow(trials) #get the overall trial number ignoring late trials and collapsing across subjects
#Create indices from 1:n_f for each fractal image. To do this, first create a mini-df with one column having all the fA_img values and the other two
#columns having indices for fA and fB. This assumes that every fA_img is paired with a unique fB_img.
f_index_df <- data.frame(fA_img = unique(trials$fA_img),fA_ix = 1:length(unique(trials$fA_img)),fB_ix = (1:length(unique(trials$fA_img))+length(unique(trials$fA_img))))
trials <- left_join(trials,f_index_df,by="fA_img")
#get the chosen fractal index
trials <- trials %>% mutate(chosen_frac = ifelse(choice == "fA",fA_ix,fB_ix))
trials <- trials %>% mutate(unchosen_frac = ifelse(choice == "fA",fB_ix,fA_ix))
two_q_pe <- fit_stan_model(stan_file=paste0(stan_model_dir,"two_q_pe.stan"),
model_out_dir=model_out_dir,
raw_data=trials,
study = "arlbv",
chains = 3,
n_t = 144)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores=12)
##SET MANUALLY
path_to_project_directory <- "~/projects/s22_follow_up/"
path_to_s22 <- "~/projects/spring_2022_study/"
##############
stan_model_dir_s22fu <- paste0(path_to_project_directory,"code/stan_models/")
stan_model_dir_s22 <- paste0(path_to_s22,"code/stan_models/final_models/")
model_out_dir <- paste0(path_to_project_directory,"output/results/stan_model_fits/")
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(loo)
library(GGally)
library(bayesplot)
library(sigmoid)
library(abind)
source(paste0(path_to_project_directory,"code/functions/s22fu_utilities.R"))
source(paste0(path_to_s22,"code/functions/s22_utilities.R"))
source(paste0(path_to_s22,"code/functions/stan_utilities.R"))
source(paste0(path_to_s22,"code/functions/fit_stan_model.R"))
trials <- read.csv(paste0(path_to_project_directory,"analysis_data/trial_level_data_all_subs_2023-06-12_09_56_03.csv"))
subs <- read.csv(paste0(path_to_project_directory,"analysis_data/sub_level_data_all_subs_2023-06-12_09_56_03.csv"))
#identify subjects who fail the hard QC cutoffs
sub_hard_fail <- subs %>% filter(att_checks_passed < 3 |
percent_left > .8 |
percent_left < .2 |
consecutive_late_choices > 5 |
late_percent > .2 |
answers_incorrect > 2 |
trials_completed < 104 |
valrate_skipped_percent > .14 |
valence_sd < .1 |
decrate_sd < .05 |
feedrate_sd < .05)
#count the number of soft QC cutoffs each subject meets
subs$softs <- 0
for(i in 1:nrow(subs)){
subs$softs[i] <- length(which(c(subs$consecutive_auto_process[i] > 4,subs$att_checks_passed[i] < 4,subs$answers_incorrect[i] > 1,
subs$late_percent[i] > .1,subs$valrate_skipped_percent[i] > .07,
subs$choice_pt_completed[i] == 0, subs$decrate_pt_completed[i] == 0, subs$feedrate_pt_completed == 0)))
}
sub_soft_fail <- filter(subs,softs >= 2) #identify those who meet more than 2 soft cutoffs
subs_to_exclude <- unique(c(sub_hard_fail$id,sub_soft_fail$id)) #mark subjects who fail on either hard or soft or criteria for exclusion
trials <- trials %>% filter(!(id %in% subs_to_exclude)) %>% filter(choice != "late") #filter out bad subjects, as well as trials on which the subject failed to make a choice
subs <- subs %>% filter(!(id %in% subs_to_exclude))
trials <- add_sub_indices(trials) #add subject indices to the df. These will match the indices used in Stan.
#add a column with completed trial numbers - the trial indices if you ignore late trials. These will match the "t" trial numbers used in the Stan models
trials <- do.call(rbind,by(trials,trials$sub_index,add_trials_nl))
trials$overall_trial_nl <- 1:nrow(trials) #get the overall trial number ignoring late trials and collapsing across subjects
#get mean-centered trial and block predictors for easier fitting in Stan
trials$trial_nl_cent <- trials$trial_nl - mean(trials$trial_nl)
trials$block_cent <- trials$block - mean(trials$block)
#Create indices from 1:n_f for each fractal image. To do this, first create a mini-df with one column having all the fA_img values and the other two
#columns having indices for fA and fB. This assumes that every fA_img is paired with a unique fB_img.
f_index_df <- data.frame(fA_img = unique(trials$fA_img),fA_ix = 1:length(unique(trials$fA_img)),fB_ix = (1:length(unique(trials$fA_img))+length(unique(trials$fA_img))))
trials <- left_join(trials,f_index_df,by="fA_img")
#get the chosen fractal index
trials <- trials %>% mutate(chosen_frac = ifelse(choice == "fA",fA_ix,fB_ix))
trials <- trials %>% mutate(unchosen_frac = ifelse(choice == "fA",fB_ix,fA_ix))
#add a column with the affect probe number for each subject (999 if no probe response). These will be passed into Stan
trials <- add_probe_number(trials,newcol="dec_probe_number",val_col="dec_rate") #for decision probes
trials <- add_probe_number(trials,newcol="feed_probe_number",val_col="feed_rate") #for decision probes
model_pred_arl_nonuis_pe <- fit_stan_model(stan_file = paste0(stan_model_dir_s22fu,"model_pred_arl_nonuis_pe.stan"),
model_out_dir = model_out_dir,
raw_data = trials,
study = "s22fu",
iter_sampling = 1500,
n_t=104)
model_pred_arl_nonuis <- read_fsml("model_pred_arl_nonuis")
model_pred_arl_nonuis <- read_fsml("model_pred_arl_nonuis",model_out_dir="/Users/dp/projects/spring_2022_study/output/results/stan_model_fits")
model_pred_arl_nonuis <- read_fsml("model_pred_arl_nonuis",model_out_dir="/Users/dp/projects/spring_2022_study/output/results/stan_model_fits/")
model_pred_arl_nonuis <- read_fsml("model_pred_arl_nonuis",model_out_dir="/Users/dp/projects/s22_follow_up/output/results/stan_model_fits/")
fsml_compare(model_pred_arl_nonuis,model_pred_arl_nonuis_pe)
model_pred_arl_nonuis$diagnostics
model_pred_arl_nonuis_pe$diagnostics
model_pred_arl_nonuis_pe$loo
model_pred_arl_nonuis$loo
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores=12)
path_to_project_directory <- "~/projects/ARL_bv/"
path_to_arl <- "~/projects/ARL/"
path_to_s22 <- "~/projects/spring_2022_study/"
stan_model_dir<- paste0(path_to_project_directory,"code/stan_models/final_samp_mods/")
model_out_dir <- paste0(path_to_project_directory,"output/results/stan_model_fits/final_samp_fits/")
#load custom functions
source(paste0(path_to_s22,"code/functions/s22_utilities.R"))
source(paste0(path_to_s22,"code/functions/stan_utilities.R"))
source(paste0(path_to_arl,"code/functions/arl_utilities.R"))
source(paste0(path_to_project_directory,"code/functions/arlbv_utilities.R"))
source(paste0(path_to_s22,"code/functions/fit_stan_model.R"))
library(tidyverse)
library(cmdstanr)
library(loo)
library(bayesplot)
library(tidybayes)
library(lme4)
trials <- read.csv(paste0(path_to_project_directory,"analysis_data/trial_level_data_all_subs_2023-11-27_18_52_39.243708.csv"))
subs <- read.csv(paste0(path_to_project_directory,"analysis_data/sub_level_data_all_subs_2023-11-27_18_52_39.243708.csv"))
sub_hard_fail <- subs %>% filter(att_checks_passed < 5 |
valrat_skipped_percent > .1 |
late_percent > .2 |
consecutive_late_choices > 9 |
trials_completed < 144 |
sd_valrat < .05 |
percent_left > .8 |
percent_left < .2 |
percent_left_b1 < .1 |
percent_left_b1 > .9 |
percent_left_b2 < .1 |
percent_left_b2 > .9 |
percent_left_b3 < .1 |
percent_left_b3 > .9 |
answers_incorrect > 2)
#count the number of soft QC cutoffs each subject meets
subs$softs <- 0
for(i in 1:nrow(subs)){
subs$softs[i] <- length(which(c(subs$att_checks_passed[i] == 5,subs$valrat_skipped_percent[i] > .05, subs$late_percent[i] > .15,
subs$sd_valrat[i] < .1, subs$percent_left[i] > .75, subs$percent_left[i] < .25,
subs$percent_left_b1[i] > .85, subs$percent_left_b1[i] < .15, subs$percent_left_b2[i] > .85,
subs$percent_left_b2[i] < .15,subs$percent_left_b3[i] > .85, subs$percent_left_b3[i] < .15,subs$answers_incorrect[i] > 1)))
}
sub_soft_fail <- filter(subs,softs >= 2) #identify those who meet more than 2 soft cutoffs
subs_to_exclude <- unique(c(sub_hard_fail$id,sub_soft_fail$id)) #get subjects who failed either set of criteria
#clean data
trials <- trials %>% filter(!(id %in% subs_to_exclude)) %>% filter(choice != "late")
subs <- subs %>% filter(!(id %in% subs_to_exclude))
length(subs_to_exclude)/(nrow(subs)+length(subs_to_exclude)) #get percent excluded
trials <- add_sub_indices(trials) #add subject indices to the df. These will match the indices used in Stan.
trials <- add_probe_number(trials,newcol="rat_number",val_col="valrat_z") #add rating number
#add a column with completed trial numbers - the trial indices if you ignore late trials. These will match the "t" trial numbers used in the Stan models
trials <- do.call(rbind,by(trials,trials$sub_index,add_trials_nl))
trials$overall_trial_nl <- 1:nrow(trials) #get the overall trial number ignoring late trials and collapsing across subjects
#Create indices from 1:n_f for each fractal image. To do this, first create a mini-df with one column having all the fA_img values and the other two
#columns having indices for fA and fB. This assumes that every fA_img is paired with a unique fB_img.
f_index_df <- data.frame(fA_img = unique(trials$fA_img),fA_ix = 1:length(unique(trials$fA_img)),fB_ix = (1:length(unique(trials$fA_img))+length(unique(trials$fA_img))))
trials <- left_join(trials,f_index_df,by="fA_img")
#get the chosen fractal index
trials <- trials %>% mutate(chosen_frac = ifelse(choice == "fA",fA_ix,fB_ix))
trials <- trials %>% mutate(unchosen_frac = ifelse(choice == "fA",fB_ix,fA_ix))
one_q <- read_fsml("one_q")
one_q <- read_fsml("one_q",model_out_dir=model_out_dir)
two_q <- read_fsml("one_q",model_out_dir=model_out_dir)
fsml_compare(one_q,two_q)
one_q$loo
fsml_compare(one_q,two_q)
two_q <- read_fsml("two_q",model_out_dir=model_out_dir)
fsml_compare(one_q,two_q)
two_q$loo
names(two_q)
two_q$runtime
two_q$mod
two_q$loo
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores=12)
##SET MANUALLY
path_to_project_directory <- "~/projects/s22_follow_up/"
path_to_s22 <- "~/projects/spring_2022_study/"
##############
stan_model_dir_s22fu <- paste0(path_to_project_directory,"code/stan_models/")
stan_model_dir_s22 <- paste0(path_to_s22,"code/stan_models/final_models/")
model_out_dir <- paste0(path_to_project_directory,"output/results/stan_model_fits/")
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(loo)
library(GGally)
library(bayesplot)
library(sigmoid)
library(abind)
source(paste0(path_to_project_directory,"code/functions/s22fu_utilities.R"))
source(paste0(path_to_s22,"code/functions/s22_utilities.R"))
source(paste0(path_to_s22,"code/functions/stan_utilities.R"))
source(paste0(path_to_s22,"code/functions/fit_stan_model.R"))
trials <- read.csv(paste0(path_to_project_directory,"analysis_data/trial_level_data_all_subs_2023-06-12_09_56_03.csv"))
subs <- read.csv(paste0(path_to_project_directory,"analysis_data/sub_level_data_all_subs_2023-06-12_09_56_03.csv"))
#identify subjects who fail the hard QC cutoffs
sub_hard_fail <- subs %>% filter(att_checks_passed < 3 |
percent_left > .8 |
percent_left < .2 |
consecutive_late_choices > 5 |
late_percent > .2 |
answers_incorrect > 2 |
trials_completed < 104 |
valrate_skipped_percent > .14 |
valence_sd < .1 |
decrate_sd < .05 |
feedrate_sd < .05)
#count the number of soft QC cutoffs each subject meets
subs$softs <- 0
for(i in 1:nrow(subs)){
subs$softs[i] <- length(which(c(subs$consecutive_auto_process[i] > 4,subs$att_checks_passed[i] < 4,subs$answers_incorrect[i] > 1,
subs$late_percent[i] > .1,subs$valrate_skipped_percent[i] > .07,
subs$choice_pt_completed[i] == 0, subs$decrate_pt_completed[i] == 0, subs$feedrate_pt_completed == 0)))
}
sub_soft_fail <- filter(subs,softs >= 2) #identify those who meet more than 2 soft cutoffs
subs_to_exclude <- unique(c(sub_hard_fail$id,sub_soft_fail$id)) #mark subjects who fail on either hard or soft or criteria for exclusion
trials <- trials %>% filter(!(id %in% subs_to_exclude)) %>% filter(choice != "late") #filter out bad subjects, as well as trials on which the subject failed to make a choice
subs <- subs %>% filter(!(id %in% subs_to_exclude))
trials <- add_sub_indices(trials) #add subject indices to the df. These will match the indices used in Stan.
#add a column with completed trial numbers - the trial indices if you ignore late trials. These will match the "t" trial numbers used in the Stan models
trials <- do.call(rbind,by(trials,trials$sub_index,add_trials_nl))
trials$overall_trial_nl <- 1:nrow(trials) #get the overall trial number ignoring late trials and collapsing across subjects
#get mean-centered trial and block predictors for easier fitting in Stan
trials$trial_nl_cent <- trials$trial_nl - mean(trials$trial_nl)
trials$block_cent <- trials$block - mean(trials$block)
#Create indices from 1:n_f for each fractal image. To do this, first create a mini-df with one column having all the fA_img values and the other two
#columns having indices for fA and fB. This assumes that every fA_img is paired with a unique fB_img.
f_index_df <- data.frame(fA_img = unique(trials$fA_img),fA_ix = 1:length(unique(trials$fA_img)),fB_ix = (1:length(unique(trials$fA_img))+length(unique(trials$fA_img))))
trials <- left_join(trials,f_index_df,by="fA_img")
#get the chosen fractal index
trials <- trials %>% mutate(chosen_frac = ifelse(choice == "fA",fA_ix,fB_ix))
trials <- trials %>% mutate(unchosen_frac = ifelse(choice == "fA",fB_ix,fA_ix))
#add a column with the affect probe number for each subject (999 if no probe response). These will be passed into Stan
trials <- add_probe_number(trials,newcol="dec_probe_number",val_col="dec_rate") #for decision probes
trials <- add_probe_number(trials,newcol="feed_probe_number",val_col="feed_rate") #for decision probes
simp_val_noshrink <- read_fsml("simp_val_noshrink")
simp_val_noshrink <- read_fsml("simp_val_noshrink",model_out_dir=model_out_dir)
regret_noshrink <- read_fsml("regret_noshrink",model_out_dir=model_out_dir)
pe_noshrink <- read_fsml("pe_noshrink",model_out_dir=model_out_dir)
combined_noshrink <- read_fsml("combined_noshrink",model_out_dir=model_out_dir)
null_affect <- read_fsml("null_affect",model_out_dir=model_out_dir)
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
fsml_compare(simp_val_noshrink,null_affect)
fsml_compare(regret_noshrink,null_affect)
fsml_compare(pe_noshrink,null_affect)
pe_noshrink$loo
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(loo)
library(GGally)
library(bayesplot)
library(sigmoid)
library(abind)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores=12)
##SET MANUALLY
path_to_project_directory <- "~/projects/s22_follow_up/"
path_to_s22 <- "~/projects/spring_2022_study/"
##############
stan_model_dir_s22fu <- paste0(path_to_project_directory,"code/stan_models/")
stan_model_dir_s22 <- paste0(path_to_s22,"code/stan_models/final_models/")
model_out_dir <- paste0(path_to_project_directory,"output/results/stan_model_fits/")
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(loo)
library(GGally)
library(bayesplot)
library(sigmoid)
library(abind)
source(paste0(path_to_project_directory,"code/functions/s22fu_utilities.R"))
source(paste0(path_to_s22,"code/functions/s22_utilities.R"))
source(paste0(path_to_s22,"code/functions/stan_utilities.R"))
source(paste0(path_to_s22,"code/functions/fit_stan_model.R"))
trials <- read.csv(paste0(path_to_project_directory,"analysis_data/trial_level_data_all_subs_2023-06-12_09_56_03.csv"))
subs <- read.csv(paste0(path_to_project_directory,"analysis_data/sub_level_data_all_subs_2023-06-12_09_56_03.csv"))
#identify subjects who fail the hard QC cutoffs
sub_hard_fail <- subs %>% filter(att_checks_passed < 3 |
percent_left > .8 |
percent_left < .2 |
consecutive_late_choices > 5 |
late_percent > .2 |
answers_incorrect > 2 |
trials_completed < 104 |
valrate_skipped_percent > .14 |
valence_sd < .1 |
decrate_sd < .05 |
feedrate_sd < .05)
#count the number of soft QC cutoffs each subject meets
subs$softs <- 0
for(i in 1:nrow(subs)){
subs$softs[i] <- length(which(c(subs$consecutive_auto_process[i] > 4,subs$att_checks_passed[i] < 4,subs$answers_incorrect[i] > 1,
subs$late_percent[i] > .1,subs$valrate_skipped_percent[i] > .07,
subs$choice_pt_completed[i] == 0, subs$decrate_pt_completed[i] == 0, subs$feedrate_pt_completed == 0)))
}
sub_soft_fail <- filter(subs,softs >= 2) #identify those who meet more than 2 soft cutoffs
subs_to_exclude <- unique(c(sub_hard_fail$id,sub_soft_fail$id)) #mark subjects who fail on either hard or soft or criteria for exclusion
trials <- trials %>% filter(!(id %in% subs_to_exclude)) %>% filter(choice != "late") #filter out bad subjects, as well as trials on which the subject failed to make a choice
subs <- subs %>% filter(!(id %in% subs_to_exclude))
trials <- add_sub_indices(trials) #add subject indices to the df. These will match the indices used in Stan.
#add a column with completed trial numbers - the trial indices if you ignore late trials. These will match the "t" trial numbers used in the Stan models
trials <- do.call(rbind,by(trials,trials$sub_index,add_trials_nl))
trials$overall_trial_nl <- 1:nrow(trials) #get the overall trial number ignoring late trials and collapsing across subjects
#get mean-centered trial and block predictors for easier fitting in Stan
trials$trial_nl_cent <- trials$trial_nl - mean(trials$trial_nl)
trials$block_cent <- trials$block - mean(trials$block)
#Create indices from 1:n_f for each fractal image. To do this, first create a mini-df with one column having all the fA_img values and the other two
#columns having indices for fA and fB. This assumes that every fA_img is paired with a unique fB_img.
f_index_df <- data.frame(fA_img = unique(trials$fA_img),fA_ix = 1:length(unique(trials$fA_img)),fB_ix = (1:length(unique(trials$fA_img))+length(unique(trials$fA_img))))
trials <- left_join(trials,f_index_df,by="fA_img")
#get the chosen fractal index
trials <- trials %>% mutate(chosen_frac = ifelse(choice == "fA",fA_ix,fB_ix))
trials <- trials %>% mutate(unchosen_frac = ifelse(choice == "fA",fB_ix,fA_ix))
#add a column with the affect probe number for each subject (999 if no probe response). These will be passed into Stan
trials <- add_probe_number(trials,newcol="dec_probe_number",val_col="dec_rate") #for decision probes
trials <- add_probe_number(trials,newcol="feed_probe_number",val_col="feed_rate") #for decision probes
pe_noshrink <- fit_stan_model(stan_file = paste0(stan_model_dir_s22fu,"pe_noshrink.stan"),
model_out_dir = model_out_dir,
raw_data = trials,
study = "s22fu",
n_t=104)
pe_noshrink <- fit_stan_model(stan_file = paste0(stan_model_dir_s22fu,"pe_noshrink.stan"),
model_out_dir = model_out_dir,
raw_data = trials,
study = "s22fu",
n_t=104)
test <- readRDS("/Users/dp/Downloads/fit_stan_model_outs.rds")
test$loo
mod_resid_sep <- read_fsml("mod_resid_sep",model_out_dir=model_out_dir)
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
combined_noshrink <- read_fsml("combined_noshrink",model_out_dir=model_out_dir)
regret_noshrink <- read_fsml("regret_noshrink",model_out_dir=model_out_dir)
simp_val_noshrink <- read_fsml("simp_val_noshrink",model_out_dir=model_out_dir)
null_affect <- read_fsml("null_affect",model_out_dir=model_out_dir)
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
combined_noshrink$loo
pe_noshrink$loo
regret_noshrink$loo
simp_val_noshrink$loo
null_affect$loo
24936*2
pe_noshrink$loo <- pe_noshrink$fit$loo()
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
save_list <- list("mod"=pe_noshrink$mod,"sum"=pe_noshrink$sum,"diagnostics"=pe_noshrink$diagnostics,"loo"=pe_noshrink$loo,"runtime"=pe_noshrink$runtime)
saveRDS(save_list,file="/Users/dp/projects/s22_follow_up/output/results/stan_model_fits/pe_noshrink/fit_stan_model_outs.rds")
pe_noshrink <- read_fsml("pe_noshrink")
pe_noshrink <- read_fsml("pe_noshrink",model_out_dir=model_out_dir)
fsml_compare(combined_noshrink,pe_noshrink,regret_noshrink,simp_val_noshrink,null_affect)
cs_mudraws <- get_draws_df("combined_shrink",vars=c("dpiw_mu[1]","dpiw_mu[2]","dpiw_mu[3]","fpiw_mu[1]","fpiw_mu[2]","fpiw_mu[3]","fpiw_mu[4]"))
cs_mudraws <- get_draws("combined_shrink",vars=c("dpiw_mu[1]","dpiw_mu[2]","dpiw_mu[3]","fpiw_mu[1]","fpiw_mu[2]","fpiw_mu[3]","fpiw_mu[4]"))
cs_mudraws <- get_draws("combined_shrink",vars=c("dpiw_mu[1]","dpiw_mu[2]","dpiw_mu[3]","fpiw_mu[1]","fpiw_mu[2]","fpiw_mu[3]","fpiw_mu[4]"),model_out_dir=model_out_dir)
cs_mudraws_origform <- cs_mudraws %>% transmute(choice_TDE = -`dpiw_mu[1]`, Q_ch = `dpiw_mu[1]` + `dpiw_mu[2]` + `dpiw_mu[3]`, Q_regret=`dpiw_mu[3]`,
PWRD = -`fpiw_mu[1]`,RPE = -`fpiw_mu[2]`,reward = `fpiw_mu[1]` + `fpiw_mu[2]` + `fpiw_mu[3]` + `fpiw_mu[4]`, regret = `fpiw_mu[4]`)
cs_dp1 <- get_draws("combined_shrink",vars=c("dpiw_mu[1]"))
cs_dp1 <- get_draws("combined_shrink",vars=c("dpiw_mu[1]"),model_out_dir=model_out_dir)
cs_dp2 <- get_draws("combined_shrink",vars=c("dpiw_mu[2]"),model_out_dir=model_out_dir))
cs_dp1 <- get_draws("combined_shrink",vars=c("dpiw_mu[1]"),model_out_dir=model_out_dir)
cs_dp2 <- get_draws("combined_shrink",vars=c("dpiw_mu[2]"),model_out_dir=model_out_dir)
cs_dp1 <- get_draws("combined_shrink",vars=c("dpiw_mu[1]"),model_out_dir=model_out_dir)
dim(cs_dp1)
combined_shrink_fit <- load_cmdstan_fit(model_out_dir=model_out_dir,"combined_shrink")
cs_draws <- combined_shrink_fit$draws(c("dpiw_mu","fpiw_mu")) #get draws array
cs_draws["dpiw_mu[1]"]
cs_draws[,,"dpiw_mu[1]"]
cs_draws[,,"dpiw_mu[2]"] +
cs_draws[,,"dpiw_mu[2]"]
cs_draws[,,"dpiw_mu[2]"] + cs_draws[,,"dpiw_mu[1]"]
.54+.09
dimnames(cs_draws_prereg) <- list(NULL, NULL, c("SV_ch", "PE_ch", "CC_ch", "SV_out", "PE_outV", "PE_outQ", "CC_out"))
#recode this draws array to match the preregistered formulation of the model
cs_draws_prereg <- array(NA, dim = c(1000, 4, 7))
dimnames(cs_draws_prereg) <- list(NULL, NULL, c("SV_ch", "PE_ch", "CC_ch", "SV_out", "PE_outV", "PE_outQ", "CC_out"))
cs_draws_prereg[,,"SV_ch"] <- -cs_draws[,,"dpiw_mu[1]"]
cs_draws_prereg[,,"SV_ch"] <- cs_draws[,,"dpiw_mu[1]"] + cs_draws[,,"dpiw_mu[2]"] + cs_draws[,,"dpiw_mu[3]"]
cs_draws_prereg[,,"SV_ch"] <- cs_draws[,,"dpiw_mu[1]"] + cs_draws[,,"dpiw_mu[2]"] + cs_draws[,,"dpiw_mu[3]"]
cs_draws_prereg[,,"PE_ch"] <- -cs_draws[,,"dpiw_mu[1]"]
cs_draws_prereg[,,"CC_ch"] <- -cs_draws[,,"dpiw_mu[3]"]
cs_draws_prereg[,,"SV_out"] <- cs_draws[,,"fpiw_mu[1]"] + cs_draws[,,"fpiw_mu[2]"] + cs_draws[,,"fpiw_mu[3]"] + cs_draws[,,"fpiw_mu[4]"]
cs_draws_prereg[,,"PE_outV"] <- -cs_draws[,,"fpiw_mu[1]"]
cs_draws_prereg[,,"PE_outQ"] <- -cs_draws[,,"fpiw_mu[2]"]
cs_draws_prereg[,,"CC_out"] <- -cs_draws[,,"fpiw_mu[4]"]
raw_eff_intervals<- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
xmin = -.2,xmax = .85,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
raw_eff_intervals
raw_eff_intervals<- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
raw_eff_intervals
raw_eff_intervals<- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("CC_out" = "#414141","PE_outQ" = "#414141","PE_outV" = "#414141","SV_out" = "#414141",
"CC_ch" = "#414141","PE_ch" = "#414141","SV_ch" = "#414141",
"CC_out_med" = "black","PE_outQ_med" = "black","PE_outV_med" = "black","SV_out_med" = "black",
"CC_ch_med" = "black","PE_ch_med" = "black","SV_ch_med" = "black"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
raw_eff_intervals
raw_eff_intervals_prereg <- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("CC_out" = "#414141","PE_outQ" = "#414141","PE_outV" = "#414141","SV_out" = "#414141",
"CC_ch" = "#414141","PE_ch" = "#414141","SV_ch" = "#414141",
"CC_out_med" = "black","PE_outQ_med" = "black","PE_outV_med" = "black","SV_out_med" = "black",
"CC_ch_med" = "black","PE_ch_med" = "black","SV_ch_med" = "black"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
ggsave("~/Documents/active_manuscripts/s22/figures/raw_eff_intervals_prereg.pdf",raw_eff_intervals_prereg,width=1.8,height=2.7)
raw_eff_intervals_prereg <- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("SV_ch" = "#5C9ED6","PE_ch" = "#8B5FBF","CC_ch"="#D9534F",
"SV_ch_med" = "#39658D", "PE_ch_med" = "#4C2F79", "CC_ch_med" = "#8C2829")
xmin = -.2,xmax = .9,
raw_eff_intervals_prereg <- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("SV_ch" = "#5C9ED6","PE_ch" = "#8B5FBF","CC_ch"="#D9534F",
"SV_ch_med" = "#39658D", "PE_ch_med" = "#4C2F79", "CC_ch_med" = "#8C2829"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
raw_eff_intervals_prereg
raw_eff_intervals_prereg <- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("SV_ch" = "#5C9ED6","PE_ch" = "#8B5FBF","CC_ch"="#D9534F",
"SV_ch_med" = "#39658D", "PE_ch_med" = "#4C2F79", "CC_ch_med" = "#8C2829",
"SV_out" = "#5C9ED6","PE_outQ" = "#8B5FBF","PE_outV" = "#8B5FBF","CC_out"="#D9534F",
"SV_out_med" = "#39658D", "PE_outQ_med" = "#4C2F79","PE_outV_med" = "#4C2F79", "CC_out_med" = "#8C2829"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA))
raw_eff_intervals_prereg
ggsave("~/Documents/active_manuscripts/s22/figures/raw_eff_intervals_prereg.pdf",raw_eff_intervals_prereg,width=1.8,height=2.7)
ggsave("~/Documents/active_manuscripts/s22/figures/raw_eff_intervals_prereg.pdf",raw_eff_intervals_prereg,width=1.8,height=1.35)
ggsave("~/Documents/active_manuscripts/s22/figures/raw_eff_intervals_prereg.pdf",raw_eff_intervals_prereg,width=1.8,height=1.35)
raw_eff_intervals_prereg <- create_interval_plot(arr = cs_draws_prereg,names = c("CC_out","PE_outQ","PE_outV","SV_out","CC_ch","PE_ch","SV_ch"),
color_mapping = c("SV_ch" = "#5C9ED6","PE_ch" = "#8B5FBF","CC_ch"="#D9534F",
"SV_ch_med" = "#39658D", "PE_ch_med" = "#4C2F79", "CC_ch_med" = "#8C2829",
"SV_out" = "#5C9ED6","PE_outQ" = "#8B5FBF","PE_outV" = "#8B5FBF","CC_out"="#D9534F",
"SV_out_med" = "#39658D", "PE_outQ_med" = "#4C2F79","PE_outV_med" = "#4C2F79", "CC_out_med" = "#8C2829"),
xmin = -.2,xmax = .9,
percentiles = c(0.025,.25,.50,.75,.975),
dot_size = 3) +
theme(panel.grid.major.x = element_line(color = "#DCDCDC", size = .47),
panel.background = element_rect(fill = "white", color = NA),
axis.text.x = element_blank(),
axis.text.y=element_blank())
ggsave("~/Documents/active_manuscripts/s22/figures/raw_eff_intervals_prereg.pdf",raw_eff_intervals_prereg,width=1.8,height=1.35)
quantile(cs_draws_prereg[,,"SV_ch"],c(.025,.50,.975))
mean(cs_draws_prereg > 0)
mean(cs_draws_prereg[,,"SV_ch"] > 0)
quantile(cs_draws_prereg[,,"SV_ch"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"SV_ch"] > 0)
quantile(cs_draws_prereg[,,"SV_ch"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"SV_ch"] > 0)
quantile(cs_draws_prereg[,,"SV_out"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"SV_out"] > 0)
quantile(cs_draws_prereg[,,"SV_ch"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"SV_ch"] > 0)
quantile(cs_draws_prereg[,,"SV_out"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"SV_out"] > 0)
quantile(cs_draws_prereg[,,"PE_outV"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"PE_outV"] > 0)
quantile(cs_draws_prereg[,,"CC_out"],c(.025,.50,.975))
mean(cs_draws_prereg[,,"CC_out"] > 0)
ra_scd_draws <- get_draws("ratings_arl",model_out_dir=model_out_dir,vars=c("scd_beta_mu","scd_aff_sens_mu"))
quantile(ra_scd_draws[,,"scd_beta_mu"],c(.05,.50,.95))
mean(ra_scd_draws[,,"scd_beta_mu"] > 0)
quantile(ra_scd_draws[,,"scd_aff_sens_mu"],c(.05,.50,.95))
mean(ra_scd_draws[,,"scd_aff_sens_mu"] > 0)
quantile(ra_scd_draws[,,"scd_beta_mu"],c(.05,.50,.95))
mean(ra_scd_draws[,,"scd_beta_mu"] > 0)
quantile(ra_scd_draws[,,"scd_aff_sens_mu"],c(.05,.50,.95))
mean(ra_scd_draws[,,"scd_aff_sens_mu"] > 0)
quantile(ra_scd_draws[,,"scd_beta_mu"],c(.025,.50,.975))
mean(ra_scd_draws[,,"scd_beta_mu"] > 0)
quantile(ra_scd_draws[,,"scd_aff_sens_mu"],c(.025,.50,.975))
mean(ra_scd_draws[,,"scd_aff_sens_mu"] > 0)
trials_frate_scale <- trials %>% filter(!is.na(feed_rate_z)) %>% mutate(feed_rate_z=scale(feed_rate_z),chosen_out=scale(chosen_out),unchosen_out=scale(unchosen_out))
stay_fit <- lmer(stay ~ feed_rate_z + chosen_out + unchosen_out + (feed_rate_z + chosen_out + unchosen_out | sub_index),trials_frate_scale)
library(lme4)
trials_frate_scale <- trials %>% filter(!is.na(feed_rate_z)) %>% mutate(feed_rate_z=scale(feed_rate_z),chosen_out=scale(chosen_out),unchosen_out=scale(unchosen_out))
stay_fit <- lmer(stay ~ feed_rate_z + chosen_out + unchosen_out + (feed_rate_z + chosen_out + unchosen_out | sub_index),trials_frate_scale)
summary(stay_fit)
anova(stay_fit)
library(lmerTest)
detach(lme4)
detach("package:lme4", unload=TRUE)
install.packages("lmerTest")
library(lmerTest)
summary(stay_fit)
summary(stay_fit)
trials_frate_scale <- trials %>% filter(!is.na(feed_rate_z)) %>% mutate(feed_rate_z=scale(feed_rate_z),chosen_out=scale(chosen_out),unchosen_out=scale(unchosen_out))
stay_fit <- lmer(stay ~ feed_rate_z + chosen_out + unchosen_out + (feed_rate_z + chosen_out + unchosen_out | sub_index),trials_frate_scale)
summary(stay_fit)
cofint(stay_fit)
confint(stay_fit)
confint(stay_fit, which="fixed")
summary(stay_fit)
confint(stay_fit, parm = c("feed_rate_z"))
summary(stay_fit)
confint(stay_fit, parm = c("feed_rate_z","chosen_out"))
summary(stay_fit)
confint(stay_fit, parm = c("feed_rate_z","chosen_out"))
